这是一个非常经典且具有挑战性的业务场景。在飞书（Lark）这样的大型企业协作平台中，“添加好友”不仅仅是两个用户建立关联，它涉及关系型数据（申请记录、状态）与图数据（社交网络、组织架构）的混合存储，以及高并发下的数据一致性问题。

基于你提供的技术栈（Neo4j + PostgreSQL），结合飞书的高标准（实时性、可靠性），以下是详细的架构设计方案。

-----

### 1. 核心架构设计理念

   读写分离与存储分层：
       PostgreSQL (PG)： 作为“事实源头（Source of Truth）”，负责存储好友申请记录、申请状态（待处理、已通过、已拒绝）以及审计日志。利用 PG 的 ACID 特性保证状态流转不丢失。
       Neo4j： 作为“关系引擎”，负责存储确立后的好友关系。利用图数据库的特性，处理复杂的查询（如：共同好友、二度人脉、组织架构路径）。
       Redis： 负责热点数据缓存（如用户信息）和防刷限流（Rate Limiting）。
   最终一致性： 在分布式环境下，为了保证高性能，好友关系的建立采用“PG 强一致 + Neo4j 最终一致”的策略，通过消息队列解耦。

-----

### 2. 数据模型设计 (Data Modeling)

#### 2.1. PostgreSQL (关系型存储)

用于记录申请流程的生命周期。

表名：`friend_request` (好友申请表)

 字段名  类型  说明 
 ---  ---  --- 
 `id`  `BIGINT`  主键 (Snowflake算法) 
 `sender_id`  `BIGINT`  发起人 ID 
 `receiver_id`  `BIGINT`  接收人 ID 
 `status`  `SMALLINT`  0 待处理, 1 已同意, 2 已拒绝, 3 已忽略 
 `verify_msg`  `VARCHAR`  验证信息 (e.g., 我是财务部的老王) 
 `create_time`  `TIMESTAMP`  创建时间 
 `update_time`  `TIMESTAMP`  处理时间 

索引优化： 在 `(sender_id, receiver_id)` 上建立唯一索引（避免重复申请），在 `receiver_id` 上建立普通索引（查询“我的待处理申请”）。

#### 2.2. Neo4j (图存储)

用于构建高性能的社交图谱。

节点 (Node) `User`

   Properties `userId`, `name`, `avatar` (仅存少量冗余字段，详细信息查 RedisPG)

关系 (Relationship) `FRIEND`

   Type `FRIEND`
   Properties `create_time` (成为好友的时间)
   Direction 虽然 Neo4j 有方向，但好友关系通常是双向的。设计上通常存一条关系 `(A)-[FRIEND]-(B)` 并在查询时忽略方向，或者为了兼容某些单向关注逻辑，存双向。建议：存单向边，查询使用 `(a)-[FRIEND]-(b)` 无向查询。

-----

### 3. 核心业务流程设计

#### 3.1. 发起好友申请 (Send Request)

这个阶段重点是校验和通知。

1.  前置校验 (Check)
       RedisNeo4j 检查： 两人是否已经是好友？如果是，直接返回。
       Redis 频控： 限制用户 A 对用户 B 发起申请的频率（防止骚扰）。
       PG 检查： 是否有状态为 `PENDING` 的重复申请？
2.  持久化 (Persist)
       在 PostgreSQL `friend_request` 表插入一条记录，状态为 `PENDING`。
3.  消息推送 (Notify)
       写入成功后，通过 WebSocket (Netty) 推送一条“新好友申请”的红点消息给接收方 (Receiver)。
       可选： 发送 MQ 消息 `friend_request_created`，用于异步触发邮件或离线推送。

#### 3.2. 同意好友申请 (Accept Request) - 架构难点

这个阶段涉及分布式事务（PG 更新状态 + Neo4j 建立关系 + 初始化会话）。

推荐方案：基于 MQ 的最终一致性 (Reliable Eventual Consistency)

   Step 1 事务更新 PG (Local Transaction)

       开启 PG 事务。
       查询 `friend_request` 记录，校验是否为 `PENDING`。
       更新 `status` = `ACCEPTED`。
       (关键一步) 在 PG 的同一事务中，写入一张 `outbox_event` 表（本地消息表模式），记录一条 `FRIEND_ADDED` 事件。
       提交 PG 事务。

   Step 2 异步处理 (Async Processing)

       独立组件（如 Canal 或 定时任务）轮询 `outbox_event` 表，将消息投递到 RocketMQKafka。
       消费者 A (Neo4j Updater) 收到消息后，在 Neo4j 中执行 Cypher：
        ```cypher
        MATCH (aUser {userId $senderId}), (bUser {userId $receiverId})
        MERGE (a)-[FRIEND {create_time timestamp()}]-(b)
        ```
        注意幂等性：使用 `MERGE` 避免重复创建边。
       消费者 B (IM Initializer) 调用 IM 服务，为两人创建一个新的私聊会话（Conversation），并在会话中插入一条系统消息“也就是我们现在已经是好友了，开始聊天吧”。
       消费者 C (Cache Evict) 清除 Redis 中两人的好友列表缓存。

-----

### 4. 详细接口设计 (API)

#### 4.1. 申请接口

```java
POST apiv1relationsfriendapply
Body {
    targetUserId 1002,
    reason Hello, let's connect.
}
```

#### 4.2. 审核接口 (同意拒绝)

```java
PUT apiv1relationsfriendaudit
Body {
    requestId 559988,
    action ACCEPT  or REJECT
}
```

#### 4.3. 关系查询接口 (利用 Neo4j 优势)

```java
 查询我与某人是否是好友，以及共同好友数
GET apiv1relationschecktargetId=1002
```

   Cypher 实现逻辑
    ```cypher
    MATCH (aUser {userId $myId}), (bUser {userId $targetId})
    OPTIONAL MATCH (a)-[FRIEND]-(common)-[FRIEND]-(b)
    RETURN EXISTS((a)-[FRIEND]-(b)) as isFriend, count(common) as commonCount
    ```

-----

### 5. 高级特性与优化 (针对飞书级场景)

#### 5.1. Neo4j 与 PG 的数据同步兜底

由于采用异步写入，极端情况下（MQ丢失或Neo4j宕机）可能导致 PG 显示“已同意”，但 Neo4j 里没关系。

   对账机制 (Reconciliation) 每天夜间运行定时任务（SparkFlink Job），扫描 PG 中当日新增的 `ACCEPTED` 记录，比对 Neo4j 中的边。如果缺失，自动修复。

#### 5.2. 缓存策略 (Redis Strategy)

好友关系读取频率极高（每次打开聊天窗口、查看个人主页都要查）。

   数据结构 使用 Redis `Set` 或 `Bloom Filter`。
   Key `userfriendids{userId}` - Set of Friend IDs.
   逻辑
    1.  先查 Redis Set，如果 targetId 在 Set 中 - 是好友。
    2.  如果 Key 不存在，查 Neo4j，重建 Redis 缓存。
    3.  如果是好友操作（添加删除），采用 Cache Aside 模式：先更库，再删缓存。

#### 5.3. 组织架构与好友的融合

飞书的特点是基于组织架构。

   在 Neo4j 中，除了 `[FRIEND]` 关系，还有 `[BELONGS_TO]` (部门)。
   添加好友时，可以智能推荐：“你们都在 研发部，是否添加好友？”
   Neo4j 查询优势体现：
    ```cypher
     查询二度人脉（朋友的朋友）推荐
    MATCH (meUser {userId $id})-[FRIEND]-(f)-[FRIEND]-(recommend)
    WHERE NOT (me)-[FRIEND]-(recommend)
    RETURN recommend, count(f) as mutualFriends ORDER BY mutualFriends DESC
    ```

### 6. 总结架构图 (文字描述版)

1.  Client (AppWeb) - Gateway (NginxSpring Cloud Gateway) - Friend Service
2.  Friend Service 读写 PostgreSQL (处理申请状态流转)。
3.  Friend Service - RocketMQ (发送 `RelationChanged` 事件)。
4.  Graph Consumer 监听 MQ - 写入 Neo4j (建立边)。
5.  IM Consumer 监听 MQ - 调用 IM Service (创建会话)。
6.  Query Service 优先查 Redis，未命中查 Neo4j (获取好友列表关系状态)。

### 7. 下一步建议

为了让这个设计落地，你需要优先实现双写一致性的代码。

Would you like me to provide the Java code for the Friend Request Approval method, specifically demonstrating the local transaction combined with the MQ event publication (是否需要我提供“同意好友申请”的 Java 核心代码，重点展示本地事务与 MQ 消息发布的结合？)